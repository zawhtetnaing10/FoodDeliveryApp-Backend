// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: orders.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const calculateTotalCost = `-- name: CalculateTotalCost :one
SELECT SUM(f.price * t.quantity)::numeric
FROM food_items AS f
CROSS JOIN LATERAL
    jsonb_to_recordset(
        $1::jsonb
    ) AS t(id INT, quantity INT)
WHERE 
f.id = t.id
`

func (q *Queries) CalculateTotalCost(ctx context.Context, items []byte) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, calculateTotalCost, items)
	var column_1 pgtype.Numeric
	err := row.Scan(&column_1)
	return column_1, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders(user_id, delivery_address_id, payment_method_id, total_cost, order_number, created_at, updated_at)
VALUES(
    $1,
    $2,
    $3,
    $4,
    $5,
    NOW() AT TIME ZONE 'UTC',
    NOW() AT TIME ZONE 'UTC'
)
RETURNING id, total_cost, order_number, user_id, delivery_address_id, payment_method_id, created_at, updated_at, deleted_at
`

type CreateOrderParams struct {
	UserID            pgtype.Int8
	DeliveryAddressID pgtype.Int8
	PaymentMethodID   pgtype.Int8
	TotalCost         pgtype.Numeric
	OrderNumber       string
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.UserID,
		arg.DeliveryAddressID,
		arg.PaymentMethodID,
		arg.TotalCost,
		arg.OrderNumber,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TotalCost,
		&i.OrderNumber,
		&i.UserID,
		&i.DeliveryAddressID,
		&i.PaymentMethodID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrderById = `-- name: GetOrderById :many
SELECT o.id AS order_id,
 o.order_number AS order_number,
 o.total_cost AS order_total_cost,
 o.created_at AS order_created_at,
 o.updated_at AS order_updated_at,
 f.id AS food_item_id,
 f.name AS food_item_name,
 f.image_url AS food_item_image_url,
 f.description AS food_item_description,
 f.price AS food_item_price,
 f.created_at AS food_item_created_at,
 f.updated_at AS food_item_updated_at,
 fho.quantity AS food_item_quantity,
 da.id AS delivery_address_id,
 da.street_address AS delivery_address,
 da.created_at AS delivery_address_created_at,
 da.updated_at AS delivery_address_updated_at,
 pm.id AS payment_method_id,
 pm.card_number AS payment_method_card_number,
 pm.expiry_date AS payment_method_expiry_date,
 pm.cvv AS payment_method_cvv,
 pm.name_on_card AS payment_method_name_on_card,
 pm.created_at AS payment_method_created_at,
 pm.updated_at AS payment_method_updated_at
FROM orders o 
INNER JOIN food_items_has_orders fho
ON fho.order_id = o.id
INNER JOIN food_items f
ON f.id = fho.food_item_id
INNER JOIN delivery_addresses da
ON o.delivery_address_id = da.id
INNER JOIN payment_methods pm
ON o.payment_method_id = pm.id
WHERE o.id = $1
`

type GetOrderByIdRow struct {
	OrderID                  int64
	OrderNumber              string
	OrderTotalCost           pgtype.Numeric
	OrderCreatedAt           pgtype.Timestamp
	OrderUpdatedAt           pgtype.Timestamp
	FoodItemID               int64
	FoodItemName             string
	FoodItemImageUrl         string
	FoodItemDescription      string
	FoodItemPrice            pgtype.Numeric
	FoodItemCreatedAt        pgtype.Timestamp
	FoodItemUpdatedAt        pgtype.Timestamp
	FoodItemQuantity         int32
	DeliveryAddressID        int64
	DeliveryAddress          string
	DeliveryAddressCreatedAt pgtype.Timestamp
	DeliveryAddressUpdatedAt pgtype.Timestamp
	PaymentMethodID          int64
	PaymentMethodCardNumber  string
	PaymentMethodExpiryDate  string
	PaymentMethodCvv         int32
	PaymentMethodNameOnCard  string
	PaymentMethodCreatedAt   pgtype.Timestamp
	PaymentMethodUpdatedAt   pgtype.Timestamp
}

func (q *Queries) GetOrderById(ctx context.Context, id int64) ([]GetOrderByIdRow, error) {
	rows, err := q.db.Query(ctx, getOrderById, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderByIdRow
	for rows.Next() {
		var i GetOrderByIdRow
		if err := rows.Scan(
			&i.OrderID,
			&i.OrderNumber,
			&i.OrderTotalCost,
			&i.OrderCreatedAt,
			&i.OrderUpdatedAt,
			&i.FoodItemID,
			&i.FoodItemName,
			&i.FoodItemImageUrl,
			&i.FoodItemDescription,
			&i.FoodItemPrice,
			&i.FoodItemCreatedAt,
			&i.FoodItemUpdatedAt,
			&i.FoodItemQuantity,
			&i.DeliveryAddressID,
			&i.DeliveryAddress,
			&i.DeliveryAddressCreatedAt,
			&i.DeliveryAddressUpdatedAt,
			&i.PaymentMethodID,
			&i.PaymentMethodCardNumber,
			&i.PaymentMethodExpiryDate,
			&i.PaymentMethodCvv,
			&i.PaymentMethodNameOnCard,
			&i.PaymentMethodCreatedAt,
			&i.PaymentMethodUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersForUser = `-- name: GetOrdersForUser :many
SELECT o.id AS order_id,
 o.order_number AS order_number,
 o.total_cost AS order_total_cost,
 o.created_at AS order_created_at,
 o.updated_at AS order_updated_at,
 f.id AS food_item_id,
 f.name AS food_item_name,
 f.image_url AS food_item_image_url,
 f.description AS food_item_description,
 f.price AS food_item_price,
 f.created_at AS food_item_created_at,
 f.updated_at AS food_item_updated_at,
 fho.quantity AS food_item_quantity,
 da.id AS delivery_address_id,
 da.street_address AS delivery_address,
 da.created_at AS delivery_address_created_at,
 da.updated_at AS delivery_address_updated_at,
 pm.id AS payment_method_id,
 pm.card_number AS payment_method_card_number,
 pm.expiry_date AS payment_method_expiry_date,
 pm.cvv AS payment_method_cvv,
 pm.name_on_card AS payment_method_name_on_card,
 pm.created_at AS payment_method_created_at,
 pm.updated_at AS payment_method_updated_at
FROM orders o 
INNER JOIN food_items_has_orders fho
ON fho.order_id = o.id
INNER JOIN food_items f
ON f.id = fho.food_item_id
INNER JOIN delivery_addresses da
ON o.delivery_address_id = da.id
INNER JOIN payment_methods pm
ON o.payment_method_id = pm.id
WHERE o.user_id = $1
`

type GetOrdersForUserRow struct {
	OrderID                  int64
	OrderNumber              string
	OrderTotalCost           pgtype.Numeric
	OrderCreatedAt           pgtype.Timestamp
	OrderUpdatedAt           pgtype.Timestamp
	FoodItemID               int64
	FoodItemName             string
	FoodItemImageUrl         string
	FoodItemDescription      string
	FoodItemPrice            pgtype.Numeric
	FoodItemCreatedAt        pgtype.Timestamp
	FoodItemUpdatedAt        pgtype.Timestamp
	FoodItemQuantity         int32
	DeliveryAddressID        int64
	DeliveryAddress          string
	DeliveryAddressCreatedAt pgtype.Timestamp
	DeliveryAddressUpdatedAt pgtype.Timestamp
	PaymentMethodID          int64
	PaymentMethodCardNumber  string
	PaymentMethodExpiryDate  string
	PaymentMethodCvv         int32
	PaymentMethodNameOnCard  string
	PaymentMethodCreatedAt   pgtype.Timestamp
	PaymentMethodUpdatedAt   pgtype.Timestamp
}

func (q *Queries) GetOrdersForUser(ctx context.Context, userID pgtype.Int8) ([]GetOrdersForUserRow, error) {
	rows, err := q.db.Query(ctx, getOrdersForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersForUserRow
	for rows.Next() {
		var i GetOrdersForUserRow
		if err := rows.Scan(
			&i.OrderID,
			&i.OrderNumber,
			&i.OrderTotalCost,
			&i.OrderCreatedAt,
			&i.OrderUpdatedAt,
			&i.FoodItemID,
			&i.FoodItemName,
			&i.FoodItemImageUrl,
			&i.FoodItemDescription,
			&i.FoodItemPrice,
			&i.FoodItemCreatedAt,
			&i.FoodItemUpdatedAt,
			&i.FoodItemQuantity,
			&i.DeliveryAddressID,
			&i.DeliveryAddress,
			&i.DeliveryAddressCreatedAt,
			&i.DeliveryAddressUpdatedAt,
			&i.PaymentMethodID,
			&i.PaymentMethodCardNumber,
			&i.PaymentMethodExpiryDate,
			&i.PaymentMethodCvv,
			&i.PaymentMethodNameOnCard,
			&i.PaymentMethodCreatedAt,
			&i.PaymentMethodUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
